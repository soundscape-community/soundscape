//
//  BehaviorBase.swift
//  Soundscape
//
//  Copyright (c) Microsoft Corporation.
//  Licensed under the MIT License.
//

import Foundation
import CoreLocation

typealias BehaviorEventForwarder = (_ event: Event,
                                   _ blockedAuto: [AutomaticGenerator.Type],
                                   _ blockedManual: [ManualGenerator.Type],
                                   _ completion: @escaping ([HandledEventAction]?) -> Void) -> Void

@MainActor
final class BehaviorEventStreams {
    private var allContinuation: AsyncStream<Event>.Continuation?
    private var userContinuation: AsyncStream<UserInitiatedEvent>.Continuation?
    private var stateContinuation: AsyncStream<StateChangedEvent>.Continuation?

    private var allBuffer: [Event] = []
    private var userBuffer: [UserInitiatedEvent] = []
    private var stateBuffer: [StateChangedEvent] = []

    lazy var all: AsyncStream<Event> = AsyncStream(Event.self, bufferingPolicy: .unbounded) { continuation in
        self.allContinuation = continuation

        if !self.allBuffer.isEmpty {
            self.allBuffer.forEach { continuation.yield($0) }
            self.allBuffer.removeAll()
        }

        continuation.onTermination = { [weak self] _ in
            Task { @MainActor in
                self?.allContinuation = nil
            }
        }
    }

    lazy var userInitiated: AsyncStream<UserInitiatedEvent> = AsyncStream(UserInitiatedEvent.self, bufferingPolicy: .unbounded) { continuation in
        self.userContinuation = continuation

        if !self.userBuffer.isEmpty {
            self.userBuffer.forEach { continuation.yield($0) }
            self.userBuffer.removeAll()
        }

        continuation.onTermination = { [weak self] _ in
            Task { @MainActor in
                self?.userContinuation = nil
            }
        }
    }

    lazy var stateChanged: AsyncStream<StateChangedEvent> = AsyncStream(StateChangedEvent.self, bufferingPolicy: .unbounded) { continuation in
        self.stateContinuation = continuation

        if !self.stateBuffer.isEmpty {
            self.stateBuffer.forEach { continuation.yield($0) }
            self.stateBuffer.removeAll()
        }

        continuation.onTermination = { [weak self] _ in
            Task { @MainActor in
                self?.stateContinuation = nil
            }
        }
    }

    func publish(_ event: Event) {
        if let allContinuation {
            allContinuation.yield(event)
        } else {
            allBuffer.append(event)
        }

        if let userEvent = event as? UserInitiatedEvent {
            if let userContinuation {
                userContinuation.yield(userEvent)
            } else {
                userBuffer.append(userEvent)
            }
        }

        if let stateEvent = event as? StateChangedEvent {
            if let stateContinuation {
                stateContinuation.yield(stateEvent)
            } else {
                stateBuffer.append(stateEvent)
            }
        }
    }

    func finish() {
        allContinuation?.finish()
        userContinuation?.finish()
        stateContinuation?.finish()

        allContinuation = nil
        userContinuation = nil
        stateContinuation = nil

        allBuffer.removeAll()
        userBuffer.removeAll()
        stateBuffer.removeAll()
    }
}

@MainActor
protocol BehaviorEventStreamSubscribing: AnyObject {
    func startEventStreamSubscriptions(userInitiatedEvents: AsyncStream<UserInitiatedEvent>,
                                       stateChangedEvents: AsyncStream<StateChangedEvent>,
                                       delegateProvider: @escaping @MainActor () -> BehaviorDelegate?) -> [Task<Void, Never>]
}

@MainActor
class BehaviorBase: Behavior {
    let id = UUID()
    
    lazy var description: String = {
        return NSStringFromClass(type(of: self)).components(separatedBy: ".").last!
    }()
    
    /// Delegate responsible for handling the callouts generated by this behavior
    weak var delegate: BehaviorDelegate?
    
    /// Indicates if the behavior is currently active
    private(set) var isActive: Bool = false
    
    /// Indicates if the behavior is currently being deactivated
    private(set) var isDeactivating: Bool = false
    
    private(set) var isInSleepMode: Bool = false
    
    /// Behaviors should keep track of the latest user location update events since generators
    /// may need that information to create callouts
    var userLocation: CLLocation?

    /// Typed event streams that generators can subscribe to.
    private let eventStreams = BehaviorEventStreams()

    private var streamSubscriptionTasks: [Task<Void, Never>] = []

    private final class StreamBox<T> {
        var continuation: AsyncStream<T>.Continuation?
    }

    private struct SubscriberStreams {
        let userStream: AsyncStream<UserInitiatedEvent>
        let userBox: StreamBox<UserInitiatedEvent>?
        let stateStream: AsyncStream<StateChangedEvent>
        let stateBox: StreamBox<StateChangedEvent>?
    }

    private var manualSubscriberBoxes: [StreamBox<UserInitiatedEvent>?] = []
    private var autoSubscriberBoxes: [StreamBox<StateChangedEvent>?] = []

    var allEvents: AsyncStream<Event> { eventStreams.all }
    var userInitiatedEvents: AsyncStream<UserInitiatedEvent> { eventStreams.userInitiated }
    var stateChangedEvents: AsyncStream<StateChangedEvent> { eventStreams.stateChanged }
    
    /// The current verbosity level of the behavior. This property is not currently being
    /// utilized but will be when openscape supports mutiple verbosity levels.
    var verbosity: Verbosity = .normal
    
    /// Set of automatic generator types in the parent behavior chain that should be blocked when
    /// this generator is active
    private(set) var blockedAutoGenerators: [AutomaticGenerator.Type]
    
    /// Set of manual generator types in the parent behavior chain that should be blocked when
    /// this generator is active
    private(set) var blockedManualGenerators: [ManualGenerator.Type]
    
    /// Generators that are manually invoked by user interaction events and always interrupt
    var manualGenerators: [ManualGenerator] = []
    
    /// Generators that are invoked by state change events and generate normal callouts that
    /// should be queued behind any callouts currently playing
    var autoGenerators: [AutomaticGenerator] = []
    
    /// Reference to the behavior this behavior is layered on top of (e.g. the default Soundscape
    /// behavior). Custom behaviors must have access to their parent behaviors so they can mediate
    /// the degree to which the parent behaviors still function when they are the active behavior.
    /// Important: This must be a strong reference.
    private(set) var parent: Behavior?
    private var parentEventForwarder: BehaviorEventForwarder?
    
    /// Initializes a behavior by setting the parent generator types that this behavior will not delegate events to.
    ///
    /// - Parameters:
    ///   - blockedAutoGenerators: Auto generator types in the parent behavior that are NOT allowed to handle events that this behavior receives
    ///   - blockedManualGenerators: Manual generator types in the parent behavior that are NOT allowed to handle events that this behavior receives but doesn't handle
    init(blockedAutoGenerators: [AutomaticGenerator.Type] = [], blockedManualGenerators: [ManualGenerator.Type] = []) {
        self.blockedAutoGenerators = blockedAutoGenerators
        self.blockedManualGenerators = blockedManualGenerators
    }
    
    /// Called by the `EventProcessor` when this behavior is activated. Adds this behavior
    /// to the top of the behavior stack.
    ///
    /// - Parameter parent: The parent behavior
    func activate(with parent: Behavior?) {
        guard !isActive else {
            GDLogError(.eventProcessor, "Attempted to activate a behavior that has already been activated!")
            return
        }
        
        self.parent = parent
        isActive = true
        GDATelemetry.track("\(description.lowercased()).activate")

        startStreamSubscriptionsIfNeeded()
    }
    
    func willDeactivate() {
        // Classes that inherit from BehaviorBase can override this method and use it for cleaning up
        // state before the behavior is deactivated.
        isDeactivating = true
    }
    
    /// Called by the `EventProcessor` when this behavior is deactivated. Removes this
    /// behavior from the top of the behavior stack.
    ///
    /// - Returns: The parent behavior if one was set
    func deactivate() -> Behavior? {
        let tempParent = parent
        parent = nil
        parentEventForwarder = nil

        stopStreamSubscriptions()
        eventStreams.finish()
        
        isActive = false
        GDATelemetry.track("\(description.lowercased()).deactivate")
        
        return tempParent
    }

    private func startStreamSubscriptionsIfNeeded() {
        stopStreamSubscriptions()

        manualSubscriberBoxes = Array(repeating: nil, count: manualGenerators.count)
        autoSubscriberBoxes = Array(repeating: nil, count: autoGenerators.count)

        final class Holder {
            let subscriber: BehaviorEventStreamSubscribing
            let userBox: StreamBox<UserInitiatedEvent>?
            let stateBox: StreamBox<StateChangedEvent>?
            let streams: SubscriberStreams

            init(subscriber: BehaviorEventStreamSubscribing, wantsUser: Bool, wantsState: Bool) {
                self.subscriber = subscriber

                let userBox: StreamBox<UserInitiatedEvent>? = wantsUser ? StreamBox<UserInitiatedEvent>() : nil
                let stateBox: StreamBox<StateChangedEvent>? = wantsState ? StreamBox<StateChangedEvent>() : nil

                self.userBox = userBox
                self.stateBox = stateBox

                let userStream: AsyncStream<UserInitiatedEvent>
                if let userBox {
                    userStream = AsyncStream(UserInitiatedEvent.self, bufferingPolicy: .unbounded) { continuation in
                        userBox.continuation = continuation
                        continuation.onTermination = { _ in
                            Task { @MainActor in
                                userBox.continuation = nil
                            }
                        }
                    }
                } else {
                    userStream = AsyncStream(UserInitiatedEvent.self) { continuation in
                        continuation.finish()
                    }
                }

                let stateStream: AsyncStream<StateChangedEvent>
                if let stateBox {
                    stateStream = AsyncStream(StateChangedEvent.self, bufferingPolicy: .unbounded) { continuation in
                        stateBox.continuation = continuation
                        continuation.onTermination = { _ in
                            Task { @MainActor in
                                stateBox.continuation = nil
                            }
                        }
                    }
                } else {
                    stateStream = AsyncStream(StateChangedEvent.self) { continuation in
                        continuation.finish()
                    }
                }

                self.streams = SubscriberStreams(userStream: userStream, userBox: userBox, stateStream: stateStream, stateBox: stateBox)
            }
        }

        struct Requirements {
            let subscriber: BehaviorEventStreamSubscribing
            var wantsUser: Bool
            var wantsState: Bool
        }

        var requirementsByObjectId: [ObjectIdentifier: Requirements] = [:]

        for generator in manualGenerators {
            guard let subscriber = generator as? BehaviorEventStreamSubscribing else { continue }
            let key = ObjectIdentifier(subscriber)
            if var existing = requirementsByObjectId[key] {
                existing.wantsUser = true
                requirementsByObjectId[key] = existing
            } else {
                requirementsByObjectId[key] = Requirements(subscriber: subscriber, wantsUser: true, wantsState: false)
            }
        }

        for generator in autoGenerators {
            guard let subscriber = generator as? BehaviorEventStreamSubscribing else { continue }
            let key = ObjectIdentifier(subscriber)
            if var existing = requirementsByObjectId[key] {
                existing.wantsState = true
                requirementsByObjectId[key] = existing
            } else {
                requirementsByObjectId[key] = Requirements(subscriber: subscriber, wantsUser: false, wantsState: true)
            }
        }

        var holdersByObjectId: [ObjectIdentifier: Holder] = requirementsByObjectId.mapValues { req in
            Holder(subscriber: req.subscriber, wantsUser: req.wantsUser, wantsState: req.wantsState)
        }

        for (index, generator) in manualGenerators.enumerated() {
            guard let subscriber = generator as? BehaviorEventStreamSubscribing else { continue }
            if let holder = holdersByObjectId[ObjectIdentifier(subscriber)] {
                manualSubscriberBoxes[index] = holder.userBox
            }
        }

        for (index, generator) in autoGenerators.enumerated() {
            guard let subscriber = generator as? BehaviorEventStreamSubscribing else { continue }
            if let holder = holdersByObjectId[ObjectIdentifier(subscriber)] {
                autoSubscriberBoxes[index] = holder.stateBox
            }
        }

        let delegateProvider: @MainActor () -> BehaviorDelegate? = { [weak self] in
            self?.delegate
        }

        for holder in holdersByObjectId.values {
            streamSubscriptionTasks.append(contentsOf: holder.subscriber.startEventStreamSubscriptions(
                userInitiatedEvents: holder.streams.userStream,
                stateChangedEvents: holder.streams.stateStream,
                delegateProvider: delegateProvider
            ))
        }
    }

    private func stopStreamSubscriptions() {
        finishSubscriberStreams()
        streamSubscriptionTasks.forEach { $0.cancel() }
        streamSubscriptionTasks.removeAll()
    }

    private func finishSubscriberStreams() {
        var finished = Set<ObjectIdentifier>()

        for box in manualSubscriberBoxes.compactMap({ $0 }) {
            let id = ObjectIdentifier(box)
            guard finished.insert(id).inserted else { continue }
            box.continuation?.finish()
            box.continuation = nil
        }

        finished.removeAll()

        for box in autoSubscriberBoxes.compactMap({ $0 }) {
            let id = ObjectIdentifier(box)
            guard finished.insert(id).inserted else { continue }
            box.continuation?.finish()
            box.continuation = nil
        }

        manualSubscriberBoxes.removeAll()
        autoSubscriberBoxes.removeAll()
    }
    
    func sleep() {
        isInSleepMode = true
    }
    
    func wake() {
        isInSleepMode = false
    }
    
    func addBlocked(auto gen: AutomaticGenerator.Type) {
        guard !blockedAutoGenerators.contains(where: { $0 == gen }) else {
            return
        }
        
        blockedAutoGenerators.append(gen)
    }
    
    func removeBlocked(auto gen: AutomaticGenerator.Type) {
        guard let index = blockedAutoGenerators.firstIndex(where: { $0 == gen }) else {
            return
        }
        
        blockedAutoGenerators.remove(at: index)
    }
    
    func addBlocked(manual gen: ManualGenerator.Type) {
        guard !blockedManualGenerators.contains(where: { $0 == gen }) else {
            return
        }
        
        blockedManualGenerators.append(gen)
    }
    
    func removeBlocked(manual gen: ManualGenerator.Type) {
        guard let index = blockedManualGenerators.firstIndex(where: { $0 == gen }) else {
            return
        }
        
        blockedManualGenerators.remove(at: index)
    }
    
    /// Method called when a new event is received by the `EventProcessor`. For events that
    /// implement `UserInitiatedEvent`, the behavior's manual generators will be checked to
    /// see if any respond to the event, and if none do, then the event will be passed to the
    /// behavior's parent. Similarly, events that implement `StateChangeEvent` will be checked
    /// to see if any of the behavior's automatic generators respond to the event, before passing
    /// the event to the behavior's parent. In either case, the event is not passed to the parent
    /// behavior if even a single generator in the behavior responds to the event.
    ///
    /// - Parameter event: An event object
    func handleEvent(_ event: Event, blockedAuto: [AutomaticGenerator.Type] = [], blockedManual: [ManualGenerator.Type] = [], completion: @escaping ([HandledEventAction]?) -> Void) {
        // Ignore events if we are in sleep mode
        guard !isInSleepMode else {
            completion(nil)
            return
        }
        
        if let locEvent = event as? LocationUpdatedEvent {
            userLocation = locEvent.location
        }

        eventStreams.publish(event)

        deliverToStreamSubscribers(event, blockedAuto: blockedAuto, blockedManual: blockedManual)
        
        switch event {
        case let event as UserInitiatedEvent:
            handleUserInteraction(event: event, blocked: blockedManual, completion: completion)
            
        case let event as StateChangedEvent:
            handleStateChange(event: event, blocked: blockedAuto, completion: completion)
            
        default:
            GDLogEventProcessorError("Unable to process event that implements neither UserInitiatedEvent nor StateChangeEvent")
            completion(nil)
        }
    }

    private func deliverToStreamSubscribers(_ event: Event,
                                           blockedAuto: [AutomaticGenerator.Type],
                                           blockedManual: [ManualGenerator.Type]) {
        if let userEvent = event as? UserInitiatedEvent {
            for (index, generator) in manualGenerators.enumerated() {
                let isBlocked = userEvent.blockable && blockedManual.contains { $0 == type(of: generator) }
                guard !isBlocked else { continue }
                guard generator.respondsTo(userEvent) else { continue }

                if index < manualSubscriberBoxes.count {
                    manualSubscriberBoxes[index]?.continuation?.yield(userEvent)
                }
                break
            }

            return
        }

        guard let stateEvent = event as? StateChangedEvent else {
            return
        }

        if stateEvent.distribution == .broadcast {
            for (index, generator) in autoGenerators.enumerated() {
                let isBlocked = stateEvent.blockable && blockedAuto.contains { $0 == type(of: generator) }
                guard !isBlocked else { continue }
                guard generator.respondsTo(stateEvent) else { continue }

                if index < autoSubscriberBoxes.count {
                    autoSubscriberBoxes[index]?.continuation?.yield(stateEvent)
                }
            }

            return
        }

        for (index, generator) in autoGenerators.enumerated() {
            let isBlocked = stateEvent.blockable && blockedAuto.contains { $0 == type(of: generator) }
            guard !isBlocked else { continue }
            guard generator.respondsTo(stateEvent) else { continue }

            if index < autoSubscriberBoxes.count {
                autoSubscriberBoxes[index]?.continuation?.yield(stateEvent)
            }
            break
        }
    }
    
    /// Attempts to generate callouts from the manual generators using this event. Note that user initiated
    /// callouts always interrupt the current callout (if it exists), clear the queue, and the enqueue their
    /// new callouts.
    ///
    /// - Parameter event: An event object
    /// - Returns: False if no generators respond to this event, true otherwise.
    private func handleUserInteraction(event: UserInitiatedEvent, blocked: [ManualGenerator.Type] = [], completion: @escaping ([HandledEventAction]?) -> Void) {
        let generators = manualGenerators.filter { gen in
            let isBlocked = event.blockable && blocked.contains { $0 == type(of: gen) }
            return !isBlocked && gen.respondsTo(event)
        }
        
        guard let generator = generators.first else {
            // None of the manual generators respond to this type of event, pass it onto the parent
            // behavior's manual generators if a parent behavior exists.
            forwardEventToParent(event, completion: completion)
            return
        }
        
        guard let delegate = delegate else {
            completion(nil)
            return
        }

        let currentVerbosity = verbosity
        Task { @MainActor in
            let actions = await generator.handle(event: event,
                                                 verbosity: currentVerbosity,
                                                 delegate: delegate)
            completion(actions)
        }
    }
    
    /// Checks if any auto generators can handle the event and if so, attempts to generate callouts
    /// for the event.
    ///
    /// - Parameter event: An event object
    private func handleStateChange(event: StateChangedEvent, blocked: [AutomaticGenerator.Type] = [], completion: @escaping ([HandledEventAction]?) -> Void) {
        let actions: [HandledEventAction]
        let generators = autoGenerators.filter { gen in
            let isBlocked = event.blockable && blocked.contains { $0 == type(of: gen) }
            return !isBlocked && gen.respondsTo(event)
        }
        
        if event.distribution == .broadcast {
            actions = generators.compactMap({ generator in
                generator.handle(event: event, verbosity: verbosity)
            })
            
            if let parentEventForwarder = parentEventForwarder {
                parentEventForwarder(event, blockedAutoGenerators, blockedManualGenerators) { parentActions in
                    guard let parentActions = parentActions else {
                        completion(actions)
                        return
                    }

                    completion(actions + parentActions)
                }

                return
            }
            
            completion(actions)
            return
        }
        
        // The event isn't being distributed to all generators, so just find the first generator that will handle it
        if let action = generators.first.flatMap({ $0.handle(event: event, verbosity: verbosity) }) {
            actions = [action]
        } else {
            actions = []
        }
        
        guard !actions.isEmpty else {
            // This behavior didn't generate any callouts, so check if the parent behavior can if this is a broadcast event
            // of there were no other generators that consumed the event
            if generators.count == 0 {
                forwardEventToParent(event, completion: completion)
                return
            }
            
            completion(nil)
            return
        }
        
        completion(actions)
    }
    private func forwardEventToParent(_ event: Event, completion: @escaping ([HandledEventAction]?) -> Void) {
        guard let parentEventForwarder = parentEventForwarder else {
            completion(nil)
            return
        }

        parentEventForwarder(event, blockedAutoGenerators, blockedManualGenerators, completion)
    }

    func setParentEventForwarder(_ forwarder: BehaviorEventForwarder?) {
        parentEventForwarder = forwarder
    }
}
